### 布尔值

```ts
let isBool: boolean = false;
```

### 数字

&emsp;&emsp;和 JavaScript 一样，TypeScript 中所有数字都是浮点数。这些浮点数的类型是 number。

```ts
let dec: number = 6;
let hex: number = 0xf00d; // 十六进制
let binary: number = 0b1010; // 二进制
let octal: number = 0o744; // 八进制
```

### 字符串

&emsp;&emsp;可以使用单引号(')或双引号(")表示字符串。

```ts
let name = "Brendan";
let username = "Eich";
```

&emsp;&emsp;还可以使用模块字符串反引号(`)来定义多行文本和内嵌表达式(\${expr})。

```ts
let firstName = "Brendan";
let lastName = "Eich";
let name = `${firstName} ${lastName}`;
```

### 数组

&emsp;&emsp;在 TypeScript 中有两种方式定义数组:

1. 类型[]

```ts
let array: number[] = [1, 2, 3];
```

2. 数组泛型：Array<类型>

```ts
let array: Array<number> = [1, 2, 3];
```

### 元组 Tuple

&emsp;&emsp;元组类型表示一组长度与类型固定的数据，各元素的类型不必相同。

```ts
let member: [string, number];

member =  = ["Tom", 23]; // ok
member = [23, "Tom"]; // Error
```

&emsp;&emsp;访问已知索引的元素，会得到正确的类型。

```ts
member[0].substr(1); // ok
member[1].substr(1); // Error,  'number' does not have 'substr'
```

&emsp;&emsp;元祖长度不能越界。

### 枚举 enum

&emsp;&emsp;

```ts
enum Color {
  Red,
  Green,
  Blue,
}
let a: Color = Color.Green;
```

&emsp;&emsp;默认下标从 0 开始，也可以手动指定成员的下标。

```ts
enum Color {
  Red = 1,
  Green,
  Blue,
}
```

### 任意值 any

&emsp;&emsp;指定 any 为类型可以忽略来自 TypeScript 的所有类型检查。any 除非必须（通常是为了向后兼容），否则不要使用。

### unknown

&emsp;&emsp;在实际上不知道类型并希望确保类型安全时使用 unknown 修饰变量。

&emsp;&emsp;使用 unknown 时，可以将所有类型关联到一个变量，但不能使用 unknown 类型转换为具有其他类型的变量。

### 空值 void

&emsp;&emsp;表示没有任何类型。

&emsp;&emsp;声明 void 类型的变量没有什么大用，因为你只能为它赋予 undefined 和 null。

```ts
let fn: void = undefined;
```

### Null 和 Undefined

&emsp;&emsp;默认情况下，null 和 undefined 是所有类型的子类型，也就是说可以把 null 和 undefined 赋值给其他类型的变量。

&emsp;&emsp;如果指定了--strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自。

&emsp;&emsp;在 JavaScript 中，用“==”进行比较时，null 和 undefined 相等。

```js
null == null; // true
undefined == undefined; // true
null == undefined; // true
```

&emsp;&emsp;可以使用 "== null"来检查 null 或 undefined。

### Never

&emsp;&emsp;never 类型表示的是那些永不存在的值的类型。

&emsp;&emsp;never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。

```ts
// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
  throw new Error(message);
}
```

### symbol

&emsp;&emsp;JavaScript 中有一个基本类型用于通过函数创建全局唯一引用 Symbol();

```ts
const firstName = Symbol("name");
const secondName = Symbol("name");

// 此条件将始终返回 "false"，因为类型 "typeof firstName" 和 "typeof secondName" 没有重叠。
firstName == secondName;
```

### bigint

&emsp;&emsp;从 ES2010 开始，JavaScript 提供了一种内置对象：BigInt，它提供了一种方法来表示大于 a<sup>53</sup> - 1 的整数（原本是 js 中可以用 Number 表示的最大数字）。BigInt 可以表示任意大的整数。

&emsp;&emsp;可以调用 BigInt()，也可以用在一个整数字面量后面加 n 的方式定义一个 BigInit。

```ts
const theBiggestInt = 9007199254740991n;

const alsoHuge = BigInt(9007199254740991);
```
